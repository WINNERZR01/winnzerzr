<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2022-New-Plan</title>
      <link href="/%E8%AE%A1%E5%88%92/2022-New-Plan/"/>
      <url>/%E8%AE%A1%E5%88%92/2022-New-Plan/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Plan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux</title>
      <link href="/Linux/Linux/"/>
      <url>/Linux/Linux/</url>
      
        <content type="html"><![CDATA[<h1 id="单用户操作系统和多用户操作系统"><a href="#单用户操作系统和多用户操作系统" class="headerlink" title="单用户操作系统和多用户操作系统"></a>单用户操作系统和多用户操作系统</h1><ul><li><strong>单用户操作系统</strong>：指一台计算机在同一时间<strong>只能由一个用户</strong>使用，一个用户独自享用系统的全部硬件和软件资源<ul><li><strong>WindowsXP</strong>之前的版本都是单用户操作系统</li></ul></li><li><strong>多用户操作系统</strong>：指一台计算机在同一时间可以由<strong>多个用户</strong>使用，多个用户共同享用系统的全部硬件和软件资源<ul><li><strong>Unix</strong>和<strong>Linux</strong>的设计初衷就是多用户操作系统</li></ul></li></ul><h1 id="Windows和Linux文件系统区别"><a href="#Windows和Linux文件系统区别" class="headerlink" title="Windows和Linux文件系统区别"></a>Windows和Linux文件系统区别</h1><h2 id="Windows下的文件系统"><a href="#Windows下的文件系统" class="headerlink" title="Windows下的文件系统"></a>Windows下的文件系统</h2><ul><li><p>在<code>Windows</code>下，打开<code>计算机</code>看到的是一个个驱动器盘符：</p><ul><li><img src="https://cdn.jsdelivr.net/gh/WINNERZR01/WINNERZR01-2022picturebed/writeimg/202201151706875.png" alt="Windows"></li></ul></li><li><p>每个驱动器都有自己的根目录结构，从而形成了多个树并列的情形，如图所示：</p><ul><li><img src="https://cdn.jsdelivr.net/gh/WINNERZR01/WINNERZR01-2022picturebed/writeimg/202201151706514.png"></li></ul></li></ul><h2 id="Linux下的文件系统"><a href="#Linux下的文件系统" class="headerlink" title="Linux下的文件系统"></a>Linux下的文件系统</h2><ul><li><p>在<code>Linux</code>下，看到的不是驱动器盘符，我们看到的是文件夹（目录）：</p></li><li><p><img src="https://cdn.jsdelivr.net/gh/WINNERZR01/WINNERZR01-2022picturebed/writeimg/202201151707947.png"></p></li><li><p><code>Ubuntu</code>下没有盘符这个概念，只有一个根目录<code>/</code>，所有文件都在它下面</p><ul><li><img src="https://cdn.jsdelivr.net/gh/WINNERZR01/WINNERZR01-2022picturebed/writeimg/202201151707370.png"></li></ul></li></ul><h2 id="用户目录"><a href="#用户目录" class="headerlink" title="用户目录"></a>用户目录</h2><ul><li><p>位于<code>/home/user</code>，称为用户工作目录或家目录，表示方式：</p><ul><li>```<br>/home/user<br>~<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## Linux主要目录速查表</span><br><span class="line"></span><br><span class="line">- /：根目录，**一般根目录下只放目录**，在Linux下有且只有一个根目录，所有的东西都是从这里开始</span><br><span class="line">  - 当在终端里输入`/home`，其实是在告诉电脑，先从`/`（根目录）开始，再进入到`home`目录</span><br><span class="line">- /bin、/usr/bin：可执行二进制文件的目录，如常用的命令`ls`、`tar`、`mv`、`cat`等</span><br><span class="line">- /boot：放置Linux系统启动时用到的一些文件，如Linux的内核文件：`/boot/vmlinuz`，系统引导管理器：`/boot/grub`</span><br><span class="line">- /dev：存放Linux系统下的设备文件，访问该目录下的某个文件，相当于访问某个设备，常用的是挂载光驱`mount /dev/cdrom/mnt`</span><br><span class="line">- /etc：系统配置文件存放的目录，不建议在此目录下存放可执行文件，重要的配置文件有</span><br><span class="line">  - /etc/inittab</span><br><span class="line">  - /etc/fstab</span><br><span class="line">  - /etc/init.d</span><br><span class="line">  - /etc/X11</span><br><span class="line">  - /etc/sysconfig</span><br><span class="line">  - /etc/xinetd.d</span><br><span class="line">- /home：系统默认的用户家目录，新增用户账号时，用户的家目录都存放在此目录下</span><br><span class="line">  - `~`表示当前用户的家目录</span><br><span class="line">  - `~edu`表示用户`edu`的家目录</span><br><span class="line">- /lib、/usr/lib、/usr/local/lib：系统使用的函数库的目录，程序在执行过程中，需要调用一些额外的参数时需要函数库的协助</span><br><span class="line">- /lost+fount：系统异常产生错误时，会将一些遗失的片段放置于此目录下</span><br><span class="line">- /mnt:/media：光盘默认挂载点，通常光盘挂载于`/mnt/cdrom`下，也不一定，可以选择任意位置进行挂载</span><br><span class="line">- /opt：给主机额外安装软件所摆放的目录</span><br><span class="line">- /proc：此目录的数据都在内存中，如系统核心 ，外部设备，网络状态，由于数据都存放于内存中，所以不占用磁盘空间，比较重要的文件有：`/proc/cpuinfo`、`/proc/interrupts`、`/proc/dma`、`/proc/ioports`、`/proc/net/*`等</span><br><span class="line">- /root：系统管理员`root`的家目录</span><br><span class="line"></span><br><span class="line"># 常用Linux终端命令的基本使用</span><br><span class="line"></span><br><span class="line">## 常用Linux命令基本使用</span><br><span class="line"></span><br><span class="line">- | 序号 | 命令           | 对应英文             | 作用                     |</span><br><span class="line">  | :--: | :------------- | :------------------- | :----------------------- |</span><br><span class="line">  |  01  | ls             | list                 | 查看当前文件夹下的内容   |</span><br><span class="line">  |  02  | pwd            | print work directory | 查看当前所在文件夹       |</span><br><span class="line">  |  03  | cd [目录名]    | change directory     | 切换文件夹               |</span><br><span class="line">  |  04  | touch [文件名] | touch                | 如果文件不存在，新建文件 |</span><br><span class="line">  |  05  | mkdir [目录名] | make directory       | 创建目录                 |</span><br><span class="line">  |  06  | rm [文件名]    | remove               | 删除指定的文件名         |</span><br><span class="line">  |  07  | clear          | clear                | 清屏                     |</span><br><span class="line"></span><br><span class="line">  &gt; 小技巧</span><br><span class="line">  &gt;</span><br><span class="line">  &gt; - `ctrl + shift + =` `放大`终端窗口的字体显示</span><br><span class="line">  &gt; - `ctrl + -` `缩小`终端窗口的字体显示</span><br><span class="line"></span><br><span class="line">## Linux终端命令格式</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>command [-options] [parameter]<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">说明：</span><br><span class="line"></span><br><span class="line">- `command`：命令名，相应功能的英文单词或单词的缩写</span><br><span class="line"></span><br><span class="line">- `[-options]`：选项，可用来对命令进行控制，也可以省略</span><br><span class="line"></span><br><span class="line">- `parameter`：传给命令的参数，可以是 `零个`、`一个`或`多个`</span><br><span class="line"></span><br><span class="line">  &gt; `[]`代表可选操作</span><br><span class="line"></span><br><span class="line">## 查阅命令帮助信息</span><br><span class="line"></span><br><span class="line">&gt; `tips`:</span><br><span class="line">&gt;</span><br><span class="line">&gt; - 现阶段只需要知道通过以下两种方式可以查询命令的帮助信息</span><br><span class="line">&gt; - 先学习`常用命令`及常用选项的使用即可，必要时可借助网络搜索</span><br><span class="line"></span><br><span class="line">- `--help`</span><br><span class="line"></span><br><span class="line">  - `command --help`</span><br><span class="line">  - 可显示`command`命令的帮助信息</span><br><span class="line"></span><br><span class="line">- `main`</span><br><span class="line"></span><br><span class="line">  - `man command`</span><br><span class="line"></span><br><span class="line">  - 查阅`command`命令的使用手册，进入之后是一个详细的文档说明</span><br><span class="line"></span><br><span class="line">    &gt; `man`是`manual`的缩写，是Linux提供的一个手册，包含了绝大部分的命令，函数的详细使用说明</span><br><span class="line">    &gt;</span><br><span class="line">    &gt; 使用`man`的操作键：</span><br><span class="line">    &gt;</span><br><span class="line">    &gt; | 操作键       | 功能                 |</span><br><span class="line">    &gt; | :----------- | -------------------- |</span><br><span class="line">    &gt; | 空格键       | 显示手册页的下一屏   |</span><br><span class="line">    &gt; | Enter键      | 一次滚动手册页的一行 |</span><br><span class="line">    &gt; | b（back）    | 回滚一屏             |</span><br><span class="line">    &gt; | f（forward） | 前滚一屏             |</span><br><span class="line">    &gt; | q（quit）    | 退出                 |</span><br><span class="line">    &gt; | /word        | 搜索`word`字符串     |</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 文件目录常用命令</span><br><span class="line"></span><br><span class="line">### 目标</span><br><span class="line"></span><br><span class="line">- 查看目录内容</span><br><span class="line">  - `ls`</span><br><span class="line">- 切换目录</span><br><span class="line">  - `cd`</span><br><span class="line">- 创建和删除操作</span><br><span class="line">  - `touch`</span><br><span class="line">  - `rm`</span><br><span class="line">  - `mkdir`</span><br><span class="line">- 拷贝和移动文件</span><br><span class="line">  - `cp`</span><br><span class="line">  - `mv`</span><br><span class="line">- 查看文件内容</span><br><span class="line">  - `cat`</span><br><span class="line">  - `more`</span><br><span class="line">  - `grep`</span><br><span class="line">- 其他</span><br><span class="line">  - `echo`</span><br><span class="line">  - 重定向`&gt;`和`&gt;&gt;`</span><br><span class="line">  - 管道`|`</span><br><span class="line"></span><br><span class="line">## 终端实用技巧</span><br><span class="line">### 自动补全</span><br><span class="line"></span><br><span class="line">- 再敲出`文件/目录/命令`的前几个字母之后，按下`tab`键</span><br><span class="line">- 如果输入的没有歧义，系统会自动补全 ，如果存在歧义，`再次`按下`tab`键会显示可能存在的命令</span><br><span class="line"></span><br><span class="line">### 曾经使用过的命令</span><br><span class="line"></span><br><span class="line">- 按`上/下`光标键可以在曾今使用过的命令之间来回切换</span><br><span class="line">- 如果想要退出选择，不想执行当前命令，可以按`Ctrl+C`</span><br><span class="line"></span><br><span class="line">## Linux下文件和目录的特点</span><br><span class="line"></span><br><span class="line">- Linux文件或目录`名称`最长可以有`256`个字符</span><br><span class="line">- 以`.`开头的文件为隐藏文件，需要用`-a`参数才能显示</span><br><span class="line">- `.`代表当前目录</span><br><span class="line">- `..`表示上一级目录</span><br><span class="line"></span><br><span class="line">## ls常用选项</span><br><span class="line"></span><br><span class="line">| 参数 | 含义                                                         |</span><br><span class="line">| ---- | ------------------------------------------------------------ |</span><br><span class="line">| -a   | 显示指定目录下所有子目录与文件，包括隐藏文件                 |</span><br><span class="line">| -l   | 以列表方式显示文件的详细信息（列表中第一列如果是`d`开头表示是文件夹） |</span><br><span class="line">| -h   | 配合-l以人性化的方式显示文件大小（`ls -l -h`或者`ls -lh`或`ls -lha`（显示所有`包括隐藏`文件的详细信息）） |</span><br><span class="line"></span><br><span class="line">&gt; `扩展`：</span><br><span class="line">&gt;</span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br><span class="line">&gt; | 单位 | 英文          | 含义                                          |</span><br><span class="line">&gt; | ---- | ------------- | --------------------------------------------- |</span><br><span class="line">&gt; | 字节 | B（byte）     | 在计算机中作为一个数字单元，一般为8位二进制数 |</span><br><span class="line">&gt; | 千   | K（kibibyte） | 1 KB = 1024 B，千字节（1024 = 2^10）          |</span><br><span class="line">&gt; | 兆   | M             | 1 MB = 1024 KB，百万字节                      |</span><br><span class="line">&gt; | 千兆 | G             | 1 GB = 1024 MB，十亿字节，千兆字节            |</span><br><span class="line">&gt; | 太   | T             | 1 TB = 1024 GB，万亿字节，太字节              |</span><br><span class="line">&gt; | 拍   | P             | 1 PB = 1024 TB，千百亿字节，拍字节            |</span><br><span class="line">&gt; | 艾   | E             | 1 EB = 1024 PB，百亿亿字节，艾字节            |</span><br><span class="line">&gt; | 泽   | Z             | 1 ZB = 1024 EB，十万亿亿字节，泽字节          |</span><br><span class="line">&gt; | 尧   | Y             | 1 YB = 1024 ZB，一亿亿亿字节，尧字节          |</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## ls通配符的使用</span><br><span class="line"></span><br><span class="line">| 通配符 | 含义                               |</span><br><span class="line">| ------ | ---------------------------------- |</span><br><span class="line">| *      | 代表任意个数个字符                 |</span><br><span class="line">| ？     | 代表任意一个字符，至少1个          |</span><br><span class="line">| []     | 表示可以匹配字符组中的任一一个     |</span><br><span class="line">| [abc]  | 匹配`a，b，c`中的任意一个          |</span><br><span class="line">| [a-f]  | 匹配从`a`到`f`范围内的任意一个字符 |</span><br><span class="line"></span><br><span class="line">## 切换目录</span><br><span class="line"></span><br><span class="line">- `cd`</span><br><span class="line"></span><br><span class="line">  - 作用：更改当前目录（`change directory`）</span><br><span class="line"></span><br><span class="line">  - &gt; 注意：Linux所有的`目录`和`文件名`都是大小写敏感的</span><br><span class="line">    &gt;</span><br><span class="line">    &gt; | 命令  | 含义                                     |</span><br><span class="line">    &gt; | ----- | ---------------------------------------- |</span><br><span class="line">    &gt; | cd    | 切换到当前用户的主目录（/home/用户目录） |</span><br><span class="line">    &gt; | cd~   | 切换到当前用户的主目录（/home/用户目录） |</span><br><span class="line">    &gt; | cd .  | 保持在当前目录不变                       |</span><br><span class="line">    &gt; | cd .. | 切换到上级目录                           |</span><br><span class="line">    &gt; | cd -  | 可以在最近两次工作目录之间来回切换       |</span><br><span class="line">    &gt;</span><br><span class="line">    &gt; </span><br><span class="line"></span><br><span class="line">- 绝对路径和相对路径</span><br><span class="line">  - `相对路径`在输入路径时，最前面不是`/`或者`~`，表示是相对于`当前目录`所在目录位置。</span><br><span class="line">  - `绝对路径`在输入路径时，最前面是`/`或者`~`，表示从`根目录/家目录`开始的具体目录位置。</span><br><span class="line"></span><br><span class="line">## 创建和删除操作</span><br><span class="line"></span><br><span class="line">- `touch`</span><br><span class="line"></span><br><span class="line">  - 如果文件`不存在`，则会创建一个空白文件。</span><br><span class="line">  - 如果文件`存在`，可以达到修改文件的末次修改日期。</span><br><span class="line"></span><br><span class="line">- `mkdir`</span><br><span class="line"></span><br><span class="line">  - 创建一个新的目录</span><br><span class="line"></span><br><span class="line">  - | 选项 | 含义                                     |</span><br><span class="line">    | ---- | ---------------------------------------- |</span><br><span class="line">    | -p   | 创建递归目录（格式：`mkdir -p a/b/c/d`） |</span><br><span class="line"></span><br><span class="line">  - &gt; `新建目录的名称`不能与当前目录中`已有的目录或文件`同名</span><br><span class="line"></span><br><span class="line">- `rm`</span><br><span class="line"></span><br><span class="line">  - 删除文件和目录</span><br><span class="line"></span><br><span class="line">  - &gt; 终端中删除的文件不会进入回收站，因此文件删除后无法恢复</span><br><span class="line">    &gt;</span><br><span class="line">  &gt; </span><br><span class="line">  &gt;</span><br><span class="line">  &gt; | 选项 | 含义                                                       |</span><br><span class="line">  &gt; | ---- | ---------------------------------------------------------- |</span><br><span class="line">  &gt; | -f   | 强制删除，忽略不存在的文件，无需提示（删除根本没有的文件） |</span><br><span class="line">  &gt; | -r   | 递归地删除目录下的内容，删除文件夹时必须加此参数           |</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 拷贝和移动文件</span><br><span class="line"></span><br><span class="line">| 序号 | 命令               | 对应英文 | 作用                              |</span><br><span class="line">| ---- | ------------------ | -------- | --------------------------------- |</span><br><span class="line">| 01   | tree [目录名]      | tree     | 以树状图列出文件目录结构          |</span><br><span class="line">| 02   | cp 源文件 目标文件 | copy     | 复制文件或目录                    |</span><br><span class="line">| 03   | mv 源文件 目标文件 | move     | 移动文件或目录/文件或者目录重命名 |</span><br><span class="line">- `tree`</span><br><span class="line"></span><br><span class="line">  - | 选项 | 含义       |</span><br><span class="line">    | ---- | ---------- |</span><br><span class="line">    | -d   | 只显示目录 |</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">- `cp`</span><br><span class="line"></span><br><span class="line">  - | 选项 | 含义                                                         |</span><br><span class="line">    | ---- | ------------------------------------------------------------ |</span><br><span class="line">    | -f   | 已经存在的目标文件直接覆盖，不会提示                         |</span><br><span class="line">    | -i   | 覆盖文件前提示是否覆盖                                       |</span><br><span class="line">    | -r   | 若给出的源文件是目录文件，则cp将递归复制到另一个文件或目录中 |</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">- `mv`</span><br><span class="line"></span><br><span class="line">  - `mv`命令可以用来移动`文件`或`目录`，也可以给文件或目录`重命名`</span><br><span class="line"></span><br><span class="line">  - | 选项 | 含义               |</span><br><span class="line">    | ---- | ------------------ |</span><br><span class="line">    | -i   | 覆盖文件前进行提示 |</span><br><span class="line"></span><br><span class="line">  ## 4.2查看文件内容</span><br><span class="line"></span><br><span class="line">  | 序号 | 命令            | 对应英文    | 作用                                                 |</span><br><span class="line">  | ---- | --------------- | ----------- | ---------------------------------------------------- |</span><br><span class="line">  | 01   | cat 文件名      | concatenate | 查看文件内容、创建文件、文件合并、追加文件内容等功能 |</span><br><span class="line">  | 02   | more 文件名     | more        | 分屏显示文件内容                                     |</span><br><span class="line">  | 03   | grep 搜索文件名 | grep        | 搜索文本文件内容                                     |</span><br><span class="line"></span><br><span class="line">- `cat`</span><br><span class="line"></span><br><span class="line">  - `cat`适合查看内容较少的文本文件</span><br><span class="line"></span><br><span class="line">  - | 选项 | 含义               |</span><br><span class="line">    | ---- | ------------------ |</span><br><span class="line">    | -b   | 对非空输出行编号   |</span><br><span class="line">    | -n   | 对输出的所有行编号 |</span><br><span class="line"></span><br><span class="line">  - &gt; Linux中还有一个命令`nl`和`cat -b`的效果等价</span><br><span class="line"></span><br><span class="line">- `more`</span><br><span class="line"></span><br><span class="line">  - `more`适合查看内容较多的文本文件</span><br><span class="line"></span><br><span class="line">  - 使用`more`的操作键：</span><br><span class="line"></span><br><span class="line">    | 操作键  | 功能                 |</span><br><span class="line">    | ------- | -------------------- |</span><br><span class="line">    | 空格键  | 显示手册页的下一屏   |</span><br><span class="line">    | Enter键 | 一次滚动手册页的一行 |</span><br><span class="line">    | b       | 回滚一屏             |</span><br><span class="line">    | f       | 前滚一屏             |</span><br><span class="line">    | q       | 退出                 |</span><br><span class="line">    | /word   | 搜索`word`字符串     |</span><br><span class="line"></span><br><span class="line">- `grep`</span><br><span class="line"></span><br><span class="line">  - Linux中`grep`是一种强大的文本内容搜索工具</span><br><span class="line"></span><br><span class="line">  - `grep`允许对文件进行模式查找，所谓模式查找，又被称为正则表达式。</span><br><span class="line"></span><br><span class="line">  - 格式：`grep 查找内容 被查找文件名`</span><br><span class="line"></span><br><span class="line">  - | 选项 | 含义                                     |</span><br><span class="line">    | ---- | ---------------------------------------- |</span><br><span class="line">    | -n   | 显示匹配行及行号                         |</span><br><span class="line">    | -v   | 显示不包括匹配文本的所有行（相当于取反） |</span><br><span class="line">    | -i   | 忽略大小写                               |</span><br><span class="line"></span><br><span class="line">  - 常用两种模式查找</span><br><span class="line"></span><br><span class="line">    | 参数 | 含义                     |</span><br><span class="line">    | ---- | ------------------------ |</span><br><span class="line">    | ^a   | 行首，搜寻以`a`开头的行  |</span><br><span class="line">    | ke$  | 行尾，搜寻以`ke`结束的行 |</span><br><span class="line"></span><br><span class="line">- `other`</span><br><span class="line"></span><br><span class="line">  - `echo` 文字内容</span><br><span class="line"></span><br><span class="line">    - `echo`会在终端中显示参数指定的文字，通常会和`重定向`联合使用</span><br><span class="line"></span><br><span class="line">  - `重定向 &gt; 和 &gt;&gt;`</span><br><span class="line"></span><br><span class="line">    - Linux允许将命令执行结果重定向到一个文件</span><br><span class="line">    - 将本应该显示在终端上的内容`输出`/`追加`到指定文件中</span><br><span class="line"></span><br><span class="line">  - 其中</span><br><span class="line"></span><br><span class="line">    - `&gt;`表示输出到一个文件中去，会覆盖文件原有的内容</span><br><span class="line">    - `&gt;&gt;`表示追加，会将内容追加到已有文件的末尾</span><br><span class="line"></span><br><span class="line">  - `管道`</span><br><span class="line"></span><br><span class="line">    - Linux允许将`一个命令的输出`可以`通过管道`作为另一个命令的`输入`</span><br><span class="line"></span><br><span class="line">    - 可以理解现实生活中的管子，管子的一头塞东西进去，另一头取东西出来，这里`|`的左右分为两端，左端塞东西（写），右端取东西（读）</span><br><span class="line"></span><br><span class="line">    - 常用的管道命令有：</span><br><span class="line"></span><br><span class="line">    - &gt; `more`：分屏显示内容</span><br><span class="line">      &gt;</span><br><span class="line">      &gt; `grep`：在命令执行结果的基础上查询指定的文本</span><br><span class="line"></span><br><span class="line">  - `关机/重启`</span><br><span class="line"></span><br><span class="line">    - | 序号 | 命令                                | 对应英文 | 作用          |</span><br><span class="line">      | ---- | ----------------------------------- | -------- | ------------- |</span><br><span class="line">      | 01   | shutdown 选项 时间（now/24:59/+10） | shutdown | 关机/重新启动 |</span><br><span class="line"></span><br><span class="line">    - `shutdown`命令可以`安全` `关闭`或者`重新启动系统`</span><br><span class="line"></span><br><span class="line">      - | 选项 | 含义         |</span><br><span class="line">        | ---- | ------------ |</span><br><span class="line">        | -r   | 重新启动     |</span><br><span class="line">        | -c   | 取消定时关机 |</span><br><span class="line"></span><br><span class="line">        &gt; `tips`：</span><br><span class="line">        &gt;</span><br><span class="line">        &gt; - `不指定选项和参数`，默认表示`1分钟`之后`关闭电脑`</span><br><span class="line">        &gt; - 远程维护服务器时，最好不要关闭系统，而应该重新启动系统</span><br><span class="line"></span><br><span class="line">## 查看或配置网卡信息</span><br><span class="line"></span><br><span class="line">| 序号 | 命令        | 对应英文                      | 作用                              |</span><br><span class="line">| ---- | ----------- | ----------------------------- | --------------------------------- |</span><br><span class="line">| 01   | ifconfig    | configure a network interface | 查看/配置计算机当前的网卡配置信息 |</span><br><span class="line">| 02   | ping ip地址 | ping                          | 检测到目标 ip地址的连接是否正常   |</span><br><span class="line"></span><br><span class="line">- `网卡`和`IP`地址</span><br><span class="line"></span><br><span class="line">  - `IP`地址是设置在网卡上的地址信息</span><br><span class="line">  - 我们可以把`电脑`比作`电话`，`网卡`相当于`SIM卡`，`IP地址`相当于`电话号码`</span><br><span class="line">  - `IP`地址：`每台联网的电脑上都有IP地址，是保证电脑之间正常通讯的重要设置`</span><br><span class="line"></span><br><span class="line">- 使用`ifconfig`为了更加方便的查找到`IP`地址</span><br><span class="line"></span><br><span class="line">  - 命令格式：`ifconfig | grep inet`</span><br><span class="line"></span><br><span class="line">  - &gt; 提示：在Linux中物理网卡的名字通常以`enXX`表示</span><br><span class="line">    &gt;</span><br><span class="line">    &gt; `127.0.0.1`被称为`本地回环/环回地址`，一般用来测试本机网卡是否正常</span><br><span class="line"></span><br><span class="line">- `ping`一般用于检测当前计算机到目标计算机之间的网络`是否通畅`，`数值越大`，`速度越慢`</span><br><span class="line"></span><br><span class="line">  - `ping`的工作原理与潜水艇的声呐相似，`ping`这个命令就是取自`声呐的声音`</span><br><span class="line"></span><br><span class="line">  - `ping`也是一个动词</span><br><span class="line"></span><br><span class="line">  - 原理： 网络上的及其都有`唯一确定的IP地址`，我们给`目标IP地址`发送一个数据包，对方就要返回一个数据包，根据返回的数据包以及时间，我们可以确定目标主机的存在</span><br><span class="line"></span><br><span class="line">  - &gt; 提示：在Linux中想要终止一个终端程序的运行，绝大多数都可以使用`Ctrl + c`</span><br><span class="line"></span><br><span class="line"># SSH学习</span><br><span class="line"></span><br><span class="line">## 远程登录和复制文件</span><br><span class="line"></span><br><span class="line">| 序号 | 命令                                              | 对应英文     | 作用          |</span><br><span class="line">| ---- | ------------------------------------------------- | ------------ | ------------- |</span><br><span class="line">| 01   | ssh 用户名@ip                                     | secure shell | 关机/重新启动 |</span><br><span class="line">| 02   | scp 用户名@ip:文件名或路径 用户名@ip:文件名或路径 | secure copy  | 远程复制文件  |</span><br><span class="line"></span><br><span class="line">- 常见服务器端口号列表：</span><br><span class="line"></span><br><span class="line">  - | 序号 | 服务      | 端口号 |</span><br><span class="line">    | ---- | --------- | ------ |</span><br><span class="line">    | 01   | SSH服务器 | 22     |</span><br><span class="line">    | 02   | Web服务器 | 80     |</span><br><span class="line">    | 03   | HTTPS     | 443    |</span><br><span class="line">    | 04   | FTP服务器 | 21     |</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">- `SSH客户端`的简单使用</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    ssh [-p port] user@remote</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>user</code>是在远程机器上的用户名，如果不指定的话默认为当前用户</p></li><li><p><code>remote</code>是远程机器的地址，可以是<code>IP/域名</code>，或者是后面提到的别名</p></li><li><p><code>port</code>是<code>SSH Server</code>监听的端口，如果不指定，就默认值<code>22</code></p><blockquote><p><code>exit</code>退出登录</p></blockquote></li><li><p><code>scp</code></p><ul><li><p><code>scp</code>是一个在Linux下用来进行<code>远程拷贝文件</code>的命令</p></li><li><p>它的地址格式与<code>ssh</code>基本相同，需要注意的是，在指定端口时用的是大写的<code>-P</code>而不是小写的</p></li><li><p>```</p><h1 id="把本地当前目录下的01-py文件，复制到-远程-家目录下的-Desktop-01-py"><a href="#把本地当前目录下的01-py文件，复制到-远程-家目录下的-Desktop-01-py" class="headerlink" title="把本地当前目录下的01.py文件，复制到 远程 家目录下的 Desktop/01.py"></a>把本地当前目录下的01.py文件，复制到 远程 家目录下的 Desktop/01.py</h1><h1 id="注意：”-”-后面的路径如果不是绝对路径，则以用户的家目录作为参照路径"><a href="#注意：”-”-后面的路径如果不是绝对路径，则以用户的家目录作为参照路径" class="headerlink" title="注意：”:” 后面的路径如果不是绝对路径，则以用户的家目录作为参照路径"></a>注意：”:” 后面的路径如果不是绝对路径，则以用户的家目录作为参照路径</h1><p>scp -P port 01.py user@remote:Desktop/01.py</p><h1 id="把远程-家目录-下的-Desktop-01-py-文件-复制到-本地当前目录下的-01-py"><a href="#把远程-家目录-下的-Desktop-01-py-文件-复制到-本地当前目录下的-01-py" class="headerlink" title="把远程 家目录 下的 Desktop/01.py 文件 复制到 本地当前目录下的 01.py"></a>把远程 家目录 下的 Desktop/01.py 文件 复制到 本地当前目录下的 01.py</h1><p>scp -P port user@remote:Desktop/01.py 01.py </p><h1 id="加上-r选项可以传送文件夹"><a href="#加上-r选项可以传送文件夹" class="headerlink" title="加上-r选项可以传送文件夹"></a>加上-r选项可以传送文件夹</h1><h1 id="把当前目录下的-demo-文件夹-复制到-远程-家目录下的-Desktop"><a href="#把当前目录下的-demo-文件夹-复制到-远程-家目录下的-Desktop" class="headerlink" title="把当前目录下的 demo 文件夹 复制到 远程 家目录下的 Desktop"></a>把当前目录下的 demo 文件夹 复制到 远程 家目录下的 Desktop</h1><p>scp -r demo user@remote:Desktop</p><h1 id="把远程家目录下的desktop复制到当前目录下的demo文件夹"><a href="#把远程家目录下的desktop复制到当前目录下的demo文件夹" class="headerlink" title="把远程家目录下的desktop复制到当前目录下的demo文件夹"></a>把远程家目录下的desktop复制到当前目录下的demo文件夹</h1><p>scp -r user@remote:Desktop demo</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## SSH高级使用技巧</span><br><span class="line"></span><br><span class="line">- `免密码登录`</span><br><span class="line"></span><br><span class="line">- `配置别名`</span><br><span class="line"></span><br><span class="line">- &gt; tips:有关`SSH`配置信息都保存在用户目录下的`.ssh`目录下</span><br><span class="line"></span><br><span class="line">- `1）免密码登录`</span><br><span class="line"></span><br><span class="line">  - 步骤</span><br><span class="line"></span><br><span class="line">  - 配置公钥</span><br><span class="line">    </span><br><span class="line">    - 执行`ssh-keygen`即可生成SSH钥匙，一路回车即可</span><br><span class="line">    </span><br><span class="line">  - 上传公钥到服务器</span><br><span class="line"></span><br><span class="line">    - 执行`ssh-copy-id -p port user@remote`，可以让服务器记住我们的公钥。</span><br><span class="line">    - ![](https://cdn.jsdelivr.net/gh/WINNERZR01/WINNERZR01-2022picturebed/writeimg/202201151707087.png)</span><br><span class="line"></span><br><span class="line">    &gt; ***非对称加密算法***</span><br><span class="line">    &gt;</span><br><span class="line">    &gt; `本地`使用`私钥`对数据进行加密/解密</span><br><span class="line">    &gt;</span><br><span class="line">    &gt; `服务器`使用`公钥`对数据进行加密/解密</span><br><span class="line"></span><br><span class="line">- `2）配置别名`</span><br><span class="line">  - 在`~/.ssh/config`里面追加以下内容：</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    Host mac（别名）</span><br><span class="line">    HostName ip地址</span><br><span class="line">    User itheima</span><br><span class="line">    Port 22</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="用户权限相关命令"><a href="#用户权限相关命令" class="headerlink" title="用户权限相关命令"></a>用户权限相关命令</h1><ul><li><p>基本概念：</p><ul><li><table><thead><tr><th>序号</th><th>权限</th><th>英文</th><th>缩写</th><th>数字代号</th></tr></thead><tbody><tr><td>01</td><td>读</td><td>read</td><td>r</td><td>4</td></tr><tr><td>02</td><td>写</td><td>write</td><td>w</td><td>2</td></tr><tr><td>03</td><td>执行</td><td>excute</td><td>x</td><td>1</td></tr></tbody></table></li></ul></li><li><p>组</p><ul><li>在实际应用中，可以预先针对组设置好权限，然后将不同的用户添加到对应的组中，从而不用依次为<code>每一个用户设置权限</code>，组内成员具有相同的权限。</li></ul></li><li><p><code>ls -l</code>扩展：</p><ul><li><code>ls -l</code>可以查看文件夹下文件的详细信息，从左到右依次是：<ul><li><code>权限</code>：第一个数字如果是<code>d</code>表示目录</li><li><code>硬连接数</code>：通俗地讲，就是有多少种方法，可以访问到当前目录/文件</li><li><code>拥有者</code>：家目录下文件/目录的拥有者通常都是当前用户</li><li><code>组</code>：在Linux中，很多时候，会出现组名和用户名相同的情况。</li><li><code>大小</code></li><li><code>时间</code></li><li><code>名称</code></li><li><img src="https://cdn.jsdelivr.net/gh/WINNERZR01/WINNERZR01-2022picturebed/writeimg/202201151707346.png"></li></ul></li></ul></li><li><p><code>chmod</code>简单使用（<code>important</code>）</p><ul><li><p><code>chmod</code>可以修改<code>用户</code>/<code>组</code>对<code>文件</code>/<code>目录</code>的权限</p></li><li><p>命令格式：</p><ul><li><pre><code>chmod +/- rwx 文件名/目录名以上方法会一次性修改拥有者或组的权限</code></pre></li><li><p>对于<code>目录</code>而言权限：</p><ul><li><code>r</code>：可以<code>cd</code>文件夹，去掉之后不能<code>ls</code>文件夹</li><li><code>w</code>：可以向文件夹中创建文件，去掉之后不能对文件夹进行更改</li><li><code>x</code>：去掉之后不能<code>cd</code>文件夹</li></ul></li></ul></li></ul></li><li><p><code>组管理</code></p><ul><li><table><thead><tr><th>序号</th><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>groupadd 组名</td><td>添加组</td></tr><tr><td>02</td><td>groupdel 组名</td><td>删除组</td></tr><tr><td>03</td><td>cat /etc/group</td><td>确认组信息</td></tr><tr><td>04</td><td>chgrp -R 组名 文件/目录名</td><td>递归修改文件/目录的所属组</td></tr></tbody></table></li></ul></li><li><p><code>创建用户/设置密码/删除用户</code></p><ul><li><table><thead><tr><th>序号</th><th>命令</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td>01</td><td><code>useradd -m -g 组 新建用户名</code></td><td>添加新用户</td><td><code>-m</code>自动建立用户目录<br /><code>-g</code>指定用户所在的组，否则默认建立一个同名的组</td></tr><tr><td>02</td><td><code>passwd 用户名</code></td><td>设置用户密码</td><td>如果是普通用户，直接用passwd可以修改自己的账户和密码</td></tr><tr><td>03</td><td><code>userdel -r 用户名</code></td><td>删除用户</td><td><code>-r</code>选项会自动删除用户家目录</td></tr><tr><td>04</td><td>`cat /etc/passwd</td><td>grep 用户名`</td><td>确认用户</td></tr></tbody></table></li></ul></li><li><p><code>查看用户信息</code></p></li><li><table><thead><tr><th>序号</th><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>id [用户名]</td><td>查看用户<code>UID</code>和<code>GID</code>信息</td></tr><tr><td>02</td><td>who</td><td>查看当前所有登录的用户列表</td></tr><tr><td>03</td><td>whoami</td><td>查看当前登录用户的账户名</td></tr></tbody></table></li><li><p><code>passwd文件</code></p><ul><li><code>/etc/passwd</code>文件存放的是用户的信息，由6个分号组成的7个信息，分别是</li><li>1.用户名</li><li>2.密码（x，表示加密的密码）</li><li>3.UID（用户标识）</li><li>4.GID（组标识）</li><li>5.用户全名或本地账号</li><li>6.家目录</li><li>7.登录使用的<code>Shell</code>，就是登录之后，使用的终端命令，<code>Ubuntu</code>默认是<code>dash</code></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gitbook Notebooks</title>
      <link href="/Gitbook/Gitbook-Notes/"/>
      <url>/Gitbook/Gitbook-Notes/</url>
      
        <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><blockquote><p><em><strong><code>I have 25 notebooks,which are based on the gitbook.</code></strong></em></p><table><thead><tr><th align="left">1.<a href="https://winnerzr01.github.io/Cnote/">C</a></th><th align="left">2.<a href="https://winnerzr01.github.io/cjiajianote/">C++</a></th><th align="left">3.<a href="https://winnerzr01.github.io/pythonnote/">Python</a></th><th align="left">4.<a href="https://winnerzr01.github.io/webnote/">Web</a></th><th align="left">5.<a href="https://winnerzr01.github.io/Linuxnote/">Linux</a></th><th align="left">6.<a href="https://winnerzr01.github.io/vimnote/">Vim</a></th></tr></thead><tbody><tr><td align="left"><strong>7.</strong><a href="https://winnerzr01.github.io/Wordnote/"><strong>Word</strong></a></td><td align="left"><strong>8.</strong><a href="https://winnerzr01.github.io/PPTnote/"><strong>PPT</strong></a></td><td align="left"><strong>9.</strong><a href="https://winnerzr01.github.io/Excelnote/"><strong>Excel</strong></a></td><td align="left"><strong>10.</strong><a href="https://winnerzr01.github.io/Soildworksnote/"><strong>Soildworks</strong></a></td><td align="left"><strong>11.</strong><a href="https://winnerzr01.github.io/rhinonote/"><strong>Rhino</strong></a></td><td align="left"><strong>12.</strong><a href="https://winnerzr01.github.io/matlabnote/"><strong>Matlab</strong></a></td></tr><tr><td align="left"><strong>13.</strong><a href="https://winnerzr01.github.io/kicadnote/"><strong>KiCAD</strong></a></td><td align="left"><strong>14.</strong><a href="https://winnerzr01.github.io/labviewnote/"><strong>Labview</strong></a></td><td align="left"><strong>15.</strong><a href="https://winnerzr01.github.io/Aenote/"><strong>Ae</strong></a></td><td align="left"><strong>16.</strong><a href="https://winnerzr01.github.io/Ainote/"><strong>Ai</strong></a></td><td align="left"><strong>17.</strong><a href="https://winnerzr01.github.io/Aunote/"><strong>Au</strong></a></td><td align="left"><strong>18.</strong><a href="https://winnerzr01.github.io/Psnote/"><strong>Ps</strong></a></td></tr><tr><td align="left"><strong>19.</strong><a href="https://winnerzr01.github.io/Prnote/"><strong>Pr</strong></a></td><td align="left"><strong>20.</strong><a href="https://winnerzr01.github.io/Dwnote/"><strong>Dw</strong></a></td><td align="left"><strong>21.</strong><a href="https://winnerzr01.github.io/Geomagicdesignx/"><strong>Geomagicdesignx</strong></a></td><td align="left"><strong>22.</strong><a href="https://winnerzr01.github.io/Ugnote/"><strong>Ug</strong></a></td><td align="left"><strong>23.</strong><a href="https://winnerzr01.github.io/Arduinonote"><strong>Arduino</strong></a></td><td align="left"><strong>24.</strong><a href="https://winnerzr01.github.io/British-English/"><strong>English</strong></a></td></tr></tbody></table></blockquote><blockquote><p>目录站：<a href="https://winnerzr01.github.io/Introduction/2022/01/20/Gitbook-Notes/">winnerzr</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Gitbook </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gitbook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows下几种连接服务器的方法</title>
      <link href="/%E6%9C%8D%E5%8A%A1%E5%99%A8/Windows%E4%B8%8B%E5%87%A0%E7%A7%8D%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/%E6%9C%8D%E5%8A%A1%E5%99%A8/Windows%E4%B8%8B%E5%87%A0%E7%A7%8D%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="如何在windows中登入到Ubuntu虚拟机"><a href="#如何在windows中登入到Ubuntu虚拟机" class="headerlink" title="如何在windows中登入到Ubuntu虚拟机"></a>如何在<code>windows</code>中登入到<code>Ubuntu</code>虚拟机</h1><hr><h2 id="方法一：使用windows自带的openssh"><a href="#方法一：使用windows自带的openssh" class="headerlink" title="方法一：使用windows自带的openssh"></a>方法一：使用<code>windows</code>自带的<code>openssh</code></h2><h4 id="1-如何开启windows自带的openssh"><a href="#1-如何开启windows自带的openssh" class="headerlink" title="1.如何开启windows自带的openssh"></a>1.如何开启<code>windows</code>自带的<code>openssh</code></h4><ul><li><p>在<em><strong>windows</strong></em>左下角搜索框搜索 <code>管理可选功能</code></p></li><li><p>点击添加功能找到<code>OpenSSH Clinent</code>或者<code>OpenSSH 客户端</code></p></li><li><p>点击之后在弹出的菜单中点击<code>安装</code>按钮，系统将进行自动安装<code>Openssh</code></p></li><li><p>返回之后就可以在 <code>管理可选功能</code> 看到<code>OpenSSH Clinent</code>或者<code>OpenSSH 客户端</code></p></li><li><p>最后重启电脑</p></li><li><p>按下 <code>win + X</code> 选择**<font color=#DC143C>以管理员身份</font>**打开powershell</p></li><li><p>输入<code>ssh</code>之后得到 <code>ssh</code>相关提示即为成功开启Openssh</p><ul><li><p><strong><font color=#DC143C>注意：</font></strong></p></li><li><p>检验 <code>Openssh</code> 是否成功开启之前</p></li><li><p>在<em><strong>windows</strong></em>左下角搜索框搜索 <strong>环境变量</strong></p></li><li><p>点击环境变量在系统环境变量中找到 <code>Path</code> 一项 点击编辑，查看是否存在 <code>Openssh</code> 的安装路径 <code>C:\Windows\System32\OpenSSH</code></p></li><li><p><strong><font color=#DC143C>注意：</font></strong></p><ul><li>如果在<code>Path</code>找不到<code>C:\Windows\System32\OpenSSH</code></li><li>就点击<ul><li>新建</li><li>浏览</li><li>找到对应路径</li><li>添加即可</li></ul></li></ul></li></ul></li></ul><hr><h4 id="2-利用windows10中的Openssh连接到Ubuntu服务器"><a href="#2-利用windows10中的Openssh连接到Ubuntu服务器" class="headerlink" title="2.利用windows10中的Openssh连接到Ubuntu服务器"></a>2.利用windows10中的Openssh连接到Ubuntu服务器</h4><ul><li>以管理员身份打开<code>powershell</code></li><li>输入<code>ssh</code>（确认是否正确开启<code>Openssh</code>服务）</li><li>继续键入<code>ssh [-p port] user@address</code><ul><li><code>user</code>是指在远程服务器上的用户名</li><li><code>[-p port]</code>可以省略，<code>port</code>是指<code>SSH Server</code>监听的端口，在没有指定时，默认为<code>22</code>号端口</li><li><code>address</code>是指远程服务器的<code>IP地址/域名/用户自己设定的别名</code><br><img src="https://cdn.jsdelivr.net/gh/WINNERZR01/WINNERZR01-2022picturebed/writeimg/202201151713274.png" alt="1"></li><li>退出服务器的方法：输入<code>exit</code> 即可</li></ul></li></ul><hr><h2 id="方法二：在windows下使用Putty工具"><a href="#方法二：在windows下使用Putty工具" class="headerlink" title="方法二：在windows下使用Putty工具"></a>方法二：在<code>windows</code>下使用<code>Putty</code>工具</h2><h4 id="工具在文章末尾有度盘链接"><a href="#工具在文章末尾有度盘链接" class="headerlink" title="工具在文章末尾有度盘链接"></a>工具在文章末尾有度盘链接</h4><ul><li><p>安装putty之后直接打开</p></li><li><p><img src="https://cdn.jsdelivr.net/gh/WINNERZR01/WINNERZR01-2022picturebed/writeimg/202201151713571.png" alt="2">在红色方框中输入 <code>Ubuntu</code> 虚拟机的 <code>IP</code></p><ul><li><p>在<code>Ubuntu</code>中输入<code>ifconfig | grep inet</code> 找到<code>inet</code>对应的<code>IP</code>地址，（127.0.0.1不用管）</p></li><li><p>输入到图中红色方框内，点击<code>Open</code></p></li><li><p>第一次点击 <code>open</code> 之后 <code>putty</code> 会选择是否信任你接下来要连接的服务器，我们点击<code>是</code></p></li><li><p>之后 <code>putty</code> 提示输入</p></li><li><p><img src="https://cdn.jsdelivr.net/gh/WINNERZR01/WINNERZR01-2022picturebed/writeimg/202201151714492.png" alt="3"></p><ul><li>想要远程登入的用户名</li><li>输入之后<code>putty</code>要求输入对应服务器的密码</li><li>想要退出所登入的服务器<ul><li>直接点右上角的 <code>×</code>(本人不建议这么做)</li><li>输入<code>exit</code>退出服务器 (比较专业)</li></ul></li></ul></li></ul></li><li><p>在你安装完<code>putty</code>之后在系统的环境变量中已经添加好 <code>putty</code> 这一项，因此你可以直接使用按照前面提到的方法打开<code>powershell</code>，输入 <code>putty</code> 之后就可以按照之前的方法打开<code>Ubuntu</code>服务器啦<br><img src="https://cdn.jsdelivr.net/gh/WINNERZR01/WINNERZR01-2022picturebed/writeimg/202201151715405.png" alt="4"></p></li></ul><h2 id="方法三：在windows下使用Xshell工具"><a href="#方法三：在windows下使用Xshell工具" class="headerlink" title="方法三：在windows下使用Xshell工具"></a>方法三：在<code>windows</code>下使用<code>Xshell</code>工具</h2><h4 id="工具在文章末尾有度盘链接-1"><a href="#工具在文章末尾有度盘链接-1" class="headerlink" title="工具在文章末尾有度盘链接"></a>工具在文章末尾有度盘链接</h4><ul><li>下载安装好Xshell之后<br><img src="https://cdn.jsdelivr.net/gh/WINNERZR01/WINNERZR01-2022picturebed/writeimg/202201151715453.png" alt="5"><br>点击新建</li><li>在主机一栏中输入<code>服务器的IP地址</code>，端口号默认</li><li>点击确定</li><li>之后提示输入服务器 <code>用户名</code> 和 <code>密码 </code></li><li>输入无误之后就可以登入到服务器啦<br>就像这样：<img src="https://cdn.jsdelivr.net/gh/WINNERZR01/WINNERZR01-2022picturebed/writeimg/202201151716388.png" alt="6"></li><li>同样适用<code>exit</code>可以退出服务器</li></ul><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">    <iframe src="//player.bilibili.com/player.html?aid=412600025&bvid=BV1zV411f7Pg&cid=173309225&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"> </iframe></div>[所用到的工具](https://pan.baidu.com/s/12m0DOSaYBJjwE3mQH3LdEw "求三连")提取码: `w84d`[简书](https://www.jianshu.com/p/b3c3333a9641 "求关注")]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人免费图床搭建与使用</title>
      <link href="/%E5%9B%BE%E5%BA%8A/%E4%B8%AA%E4%BA%BA%E5%85%8D%E8%B4%B9%E5%9B%BE%E5%BA%8A%E6%90%AD%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
      <url>/%E5%9B%BE%E5%BA%8A/%E4%B8%AA%E4%BA%BA%E5%85%8D%E8%B4%B9%E5%9B%BE%E5%BA%8A%E6%90%AD%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="图床简介"><a href="#图床简介" class="headerlink" title="图床简介"></a>图床简介</h1><p>写入博客的时候需要插入大量的图片，其中包括一些二维码，网络上的那些免费的图床都有一定的限制，在图片大小和图片类型之间会使得图片不一定可以保存很久，因此我们产生了自己通过国内的代码托管平台<a href="https://gitee.com/">Gitee</a>搭建的想法，<a href="https://github.com/">Github</a>也具有相同功能，可能速度不比国内<a href="https://gitee.com/">Gitee</a>的快。</p><blockquote><p>图床就是一个便于在博文中插入在线图片连接的个人图片仓库。设置图床之后，在自己博客中插入的图片链接就可以随时随地在线预览了，并且不会因为任何意外原因无法查看，除非在仓库中自己删除</p></blockquote><p>最终决定使用PicGo + 国内的Github（<a href="https://gitee.com/">Gitee</a>）</p><h3 id="安装所需工具"><a href="#安装所需工具" class="headerlink" title="安装所需工具"></a>安装所需工具</h3><ul><li><code>PicGo</code><ul><li>网址：<a href="https://github.com/Molunerfinn/PicGo">Download</a></li></ul></li><li><code>picgo-plugin-gitee-uploader</code>插件<ul><li>网址：<a href="https://github.com/lizhuangs/picgo-plugin-gitee-uploader#readme">Download</a></li></ul></li><li><code>Hexo</code> 博客已经搭建完成</li></ul><p><img src="https://cdn.jsdelivr.net/gh/WINNERZR01/WINNERZR01-2022picturebed/writeimg/202201151716005.png" alt="PicGo界面"></p><p><img src="https://cdn.jsdelivr.net/gh/WINNERZR01/WINNERZR01-2022picturebed/writeimg/202201151717160.png" alt="插件安装"></p><p><img src="https://cdn.jsdelivr.net/gh/WINNERZR01/WINNERZR01-2022picturebed/writeimg/202201151717199.png" alt="插件安装2"></p><h3 id="新建码云图床仓库"><a href="#新建码云图床仓库" class="headerlink" title="新建码云图床仓库"></a>新建码云图床仓库</h3><ul><li><p><img src="https://cdn.jsdelivr.net/gh/WINNERZR01/WINNERZR01-2022picturebed/writeimg/202201151717620.png" alt="第一步"></p></li><li><p><img src="https://cdn.jsdelivr.net/gh/WINNERZR01/WINNERZR01-2022picturebed/writeimg/202201151717164.png" alt="步骤2"></p></li></ul><h3 id="配置PicGo插件"><a href="#配置PicGo插件" class="headerlink" title="配置PicGo插件"></a>配置PicGo插件</h3><ul><li><p>安装<code>gitee-uploader 1.1.2</code>插件</p></li><li><p>配置插件</p><ul><li><img src="https://cdn.jsdelivr.net/gh/WINNERZR01/WINNERZR01-2022picturebed/writeimg/202201151717253.png" alt="插件配置"></li><li>获取<code>token</code><ul><li>点击头像，点击设置<ul><li><img src="https://cdn.jsdelivr.net/gh/WINNERZR01/WINNERZR01-2022picturebed/writeimg/202201151717730.png" alt="设置"></li></ul></li><li>生成<code>token</code><ul><li><img src="https://cdn.jsdelivr.net/gh/WINNERZR01/WINNERZR01-2022picturebed/writeimg/202201151717057.png" alt="生成token"><img src="https://cdn.jsdelivr.net/gh/WINNERZR01/WINNERZR01-2022picturebed/writeimg/202201151717882.png" alt="生成新token"></li><li><img src="https://cdn.jsdelivr.net/gh/WINNERZR01/WINNERZR01-2022picturebed/writeimg/202201151718183.png"></li><li><img src="https://cdn.jsdelivr.net/gh/WINNERZR01/WINNERZR01-2022picturebed/writeimg/202201151718193.png" alt="复制token"></li></ul></li></ul></li><li>输入<code>token</code>，点击确定，并设置为默认图床。</li></ul></li></ul><blockquote><p>PicGO-github链接：<a href="https://github.com/Molunerfinn/PicGo">PicGO</a></p><p>PicGO-百度云链接:<a href="https://pan.baidu.com/s/1S9QGgj0F9TAPtguI6sa4mA">PicGO</a>  <code>uq5p</code></p><p>所用插件-github链接：<a href="https://github.com/lizhuangs/picgo-plugin-gitee-uploader#readme">picgo-plugin-gitee-uploader</a></p></blockquote><h1 id="在vscode中使用PicGo插件"><a href="#在vscode中使用PicGo插件" class="headerlink" title="在vscode中使用PicGo插件"></a>在vscode中使用PicGo插件</h1><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p><img src="https://cdn.jsdelivr.net/gh/WINNERZR01/WINNERZR01-2022picturebed/writeimg/202201151718886.png" alt="如图"></p><h2 id="配置插件"><a href="#配置插件" class="headerlink" title="配置插件"></a>配置插件</h2><p><img src="https://cdn.jsdelivr.net/gh/WINNERZR01/WINNERZR01-2022picturebed/writeimg/202201151718586.png"></p><blockquote><p>这里只演示github图床的配置，其他的不是收费就是一堆限制，相对来说<code>github</code>比较自由。</p></blockquote><h3 id="Branch"><a href="#Branch" class="headerlink" title="Branch"></a>Branch</h3><ul><li>不用多解释，想要保存的<code>分支名称</code></li></ul><h3 id="Path"><a href="#Path" class="headerlink" title="Path"></a>Path</h3><ul><li>可以自己设置成想要保存的文件夹名称，注意格式应该为<code>文件夹名/</code>这个<code>/</code>是必要的</li><li>也可以选择保持空白</li></ul><h3 id="Repo"><a href="#Repo" class="headerlink" title="Repo"></a>Repo</h3><ul><li>保存的仓库名称格式为：<code>Username/Repo</code></li></ul><h3 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h3><ul><li> 在<code>github</code>的个人首页中选择设置，然后选择开发者设置生成<code>Token</code>后复制输入即可。</li><li><code>Token</code>只生成一次请注意复制保存。</li></ul><h2 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h2><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><ul><li><table><thead><tr><th align="center">System</th><th align="center">From clipboard upload</th><th align="center">From explorer upload</th><th align="center">From input box upload</th></tr></thead><tbody><tr><td align="center">Windows/Linux</td><td align="center">ctrl + alt + u</td><td align="center">ctrl + alt + e</td><td align="center">ctrl + alt + o</td></tr><tr><td align="center">macOS</td><td align="center">command + option +u</td><td align="center">command + option +e</td><td align="center">command + option +o</td></tr></tbody></table></li></ul>]]></content>
      
      
      <categories>
          
          <category> 图床 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> Vscode </tag>
            
            <tag> 图床 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python风格迁移</title>
      <link href="/Python/Python%E9%A3%8E%E6%A0%BC%E8%BF%81%E7%A7%BB/"/>
      <url>/Python/Python%E9%A3%8E%E6%A0%BC%E8%BF%81%E7%A7%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="原理简介"><a href="#原理简介" class="headerlink" title="原理简介"></a>原理简介</h1><p><strong>简单而言大概是这样</strong>：<br>利用CNN逐层提取图像的特征，并将某一层或某几层输出的Gram矩阵 作为损失函数，来衡量两幅图像之间的内容/风格差异（:smirk:其实就是两幅图像经过相同的卷积神经网络，比较某一层或者某几层输出之间的Gram矩阵的差异）</p><blockquote><p><code>CNN</code> ：是一种至少包含一层卷积层的神经网络模型，卷积层的目的是将卷积核应用到图像张量的所有点上，并通过将卷积核在输入张量上滑动生成经过滤波处理的张量．简单的CNN架构通常会包含卷积层，池化层，非线性变换层，全连接层．通过这些层网络会被填充大量的信息，因此模型便可以进行复杂的模式匹配．<br><code>Gram矩阵</code> ：</p><p><a href="https://zh.wikipedia.org/wiki/%E6%A0%BC%E6%8B%89%E5%A7%86%E7%9F%A9%E9%98%B5">格拉姆矩阵（维基百科）</a><br><a href="https://baike.baidu.com/item/%E6%A0%BC%E6%8B%89%E5%A7%86%E7%9F%A9%E9%98%B5/16274086?fr=aladdin">格拉姆矩阵（百度百科）</a></p><ul><li>So what is Gram？</li><li>As we all know 一张图片在某个卷积层的输出特征为一个形如（<code>batch_size , channels,width,height</code>）的四阶张量，显然<code>batch_size</code> 为1<img src="https://cdn.jsdelivr.net/gh/WINNERZR01/WINNERZR01-2022picturebed/writeimg/202201151708645.png" alt="l练习 1">转换为(<code>batch_size*channels</code> , <code>width*height</code>)大小的矩阵，这个矩阵和它的转置相乘就可以得到一个大小为(<code>batch_size*channels</code> ,<code>batch_size*channels</code>）的矩阵。<br><img src="https://cdn.jsdelivr.net/gh/WINNERZR01/WINNERZR01-2022picturebed/writeimg/202201151708751.png" alt="风格迁移"></li></ul></blockquote><hr><h1 id="官方文档介绍（译文）"><a href="#官方文档介绍（译文）" class="headerlink" title="官方文档介绍（译文）"></a>官方文档介绍（译文）</h1><h4 id="这是什么？"><a href="#这是什么？" class="headerlink" title="这是什么？"></a>这是什么？</h4><p>神经风格或者神经转移是 一种将输入的内容图像转换为使用输入的风格图像的艺术风 格的 内容图像的 算法 （左边的为内容图像，中间的为风格图像，右边的为转换后的图像：<br><img src="https://cdn.jsdelivr.net/gh/WINNERZR01/WINNERZR01-2022picturebed/writeimg/202201151708583.png" alt="风格迁移"> </p><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>原理很简单：我们定义了两个距离，一个代表图像内容（*D<del>c</del><em>），一个代表图像风格（</em>D<del>s</del>*）。D<del>c</del>衡量两幅图像之间的内容差异 程度 D<del>s</del>衡量两幅图像之间的风格差异程度。 然后，我们取第三幅图像作为输入（比如含噪音的空白图） 我们对其进行转换，使得它的内容与内容图像的距离最小，同时它的风格与风格图像的距离最小。</p><h5 id="具体实现："><a href="#具体实现：" class="headerlink" title="具体实现："></a>具体实现：</h5><p><img src="https://cdn.jsdelivr.net/gh/WINNERZR01/WINNERZR01-2022picturebed/writeimg/202201151708670.png" alt="具体实现"></p><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><h5 id="（1）相关包"><a href="#（1）相关包" class="headerlink" title="（1）相关包"></a>（1）相关包</h5><ul><li><em>torch</em>，<em>torch.nn</em>，<em>numpy</em>：使用<em>Pytorch</em>必不可少的包；</li><li><em>torch.autograd.Variable</em>：对变量梯度的动态计算；</li><li><em>torch .optim</em> 有效的梯度下降；</li><li><em>PIL</em> ，<em>PIL.Image</em>，<em>matplot lib.pyplot</em> ：导入和显示图片；</li><li><em>torchvision.transforms</em>：处理 PIL 图像，将其转为 torch 张量；</li><li><em>torch.models</em>：训练或导入预训练模型；</li><li><em>copy</em>：深度复制模型或系统包 。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__<span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">import</span> torch </span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Varible</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt </span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> tranforms</span><br><span class="line"><span class="keyword">import</span> torchvision.models <span class="keyword">as</span> models</span><br><span class="line"><span class="keyword">import</span> copy</span><br></pre></td></tr></table></figure><h5 id="（2）Cuda"><a href="#（2）Cuda" class="headerlink" title="（2）Cuda"></a>（2）Cuda</h5><p>如果你电脑上有 <code>GPU</code>  ，则最好在 <code>GPU</code>  上运行该算法，尤其当网络比较大时（比如 <code>VGG</code> ）。为此，我们使用 <code>torch.cuda.is_available()</code>  检测 电脑上 是否有可用 <code>GPU</code>  。 然后，我们利用<code>.cuda()</code>方法将运算移至 <code>GPU</code> 。 当我们想移回 <code>CPU</code> 时（例如使用 <code>numpy</code>时） ），<br>我们可以使用<code>.cuda() </code>方法。 最后 <code>.type(dtype)</code>  将 <code>torch.FloatTensor</code>  转换为 <code>torch.cuda.FloatTensor</code>。</p><h5 id="（3）载入图像"><a href="#（3）载入图像" class="headerlink" title="（3）载入图像"></a>（3）载入图像</h5><p>为了简化应用，我们导入相同纬度的风格和内容图像。之后，我们将它们缩放为需要的输出的图像尺寸（例如128或者512），将它们转为<code>torch</code> 张量，准备送入神经网络。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># desired size of the output image</span></span><br><span class="line">imsize = <span class="number">512</span> <span class="keyword">if</span> use_cuda <span class="keyword">else</span> <span class="number">128</span> <span class="comment"># use small size if no gpu</span></span><br><span class="line"></span><br><span class="line">loader = transforms.Compare([</span><br><span class="line">transforms.Scale(imsize), <span class="comment"># scale imported image</span></span><br><span class="line">transforms.ToTensor()] <span class="comment"># tranform it into a torch tensor</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">image_loader</span>(<span class="params">image_name</span>):</span></span><br><span class="line">image = Image.<span class="built_in">open</span>(image_name)</span><br><span class="line">image = Variable(loader(image))</span><br><span class="line"><span class="comment"># fake batch dimension required to fit network&#x27;s input dimensions</span></span><br><span class="line">image = image.unsqueeze(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> image</span><br><span class="line"></span><br><span class="line">style_img = image_loader(<span class="string">&quot;images/picasso.jpg&quot;</span>).<span class="built_in">type</span>(dtype)</span><br><span class="line">content_img = image_loader(<span class="string">&quot;images/dancing.jpg&quot;</span>).<span class="built_in">type</span>(dtype)</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> style_img.size() == content_img.size(),\</span><br><span class="line"><span class="string">&quot;we need to import style and content images of the same size&quot;</span></span><br></pre></td></tr></table></figure><p>输入的 PIL 图像像素值在 0 到 255 之间，将其转为 torch 张量后，它们的值变为 0 到 1之间。其中一个重要的细节是：从 torch 库导入的神经网络是通过 0-1 之间取值的张量图像训练的。如果你尝试用 0-255 之间取值的张量图像导入网络，获得的特征图将毫无意义。Caffe 库中预训练的网络则并非如此，它们使用 0-255 之间取值的张量训练。</p><h5 id="（4）图像显示"><a href="#（4）图像显示" class="headerlink" title="（4）图像显示"></a>（4）图像显示</h5><p>我们使用plt.imshow 函数显示图像。我们需要先将图像转为PIL图像：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">unloader = transforms.ToPILImage()  <span class="comment"># reconvert into PIL image</span></span><br><span class="line"></span><br><span class="line">plt.ion()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">imshow</span>(<span class="params">tensor, title=<span class="literal">None</span></span>):</span></span><br><span class="line">    image = tensor.clone().cpu()  <span class="comment"># we clone the tensor to not do changes on it</span></span><br><span class="line">    image = image.view(<span class="number">3</span>, imsize, imsize)  <span class="comment"># remove the fake batch dimension</span></span><br><span class="line">    image = unloader(image)</span><br><span class="line">    plt.imshow(image)</span><br><span class="line">    <span class="keyword">if</span> title <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        plt.title(title)</span><br><span class="line">    plt.pause(<span class="number">0.001</span>) <span class="comment"># pause a bit so that plots are updated</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line">imshow(style_img.data, title=<span class="string">&#x27;Style Image&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line">imshow(content_img.data, title=<span class="string">&#x27;Content Image&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/WINNERZR01/WINNERZR01-2022picturebed/writeimg/202201151709202.png" alt="结果"></p><h5 id="（5）内容损失"><a href="#（5）内容损失" class="headerlink" title="（5）内容损失"></a>（5）内容损失</h5><p><img src="https://gitee.com/zr001/my-picture-bed/raw/master/1593958589916.png" alt="内容损失"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContentLoss</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, target, weight</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(ContentLoss, self).__init__()</span><br><span class="line">        <span class="comment"># we &#x27;detach&#x27; the target content from the tree used</span></span><br><span class="line">        self.target = target.detach() * weight</span><br><span class="line">        <span class="comment"># to dynamically compute the gradient: this is a stated value,</span></span><br><span class="line">        <span class="comment"># not a variable. Otherwise the forward method of the criterion</span></span><br><span class="line">        <span class="comment"># will throw an error.</span></span><br><span class="line">        self.weight = weight</span><br><span class="line">        self.criterion = nn.MSELoss()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, <span class="built_in">input</span></span>):</span></span><br><span class="line">        self.loss = self.criterion(<span class="built_in">input</span> * self.weight, self.target)</span><br><span class="line">        self.output = <span class="built_in">input</span></span><br><span class="line">        <span class="keyword">return</span> self.output</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backward</span>(<span class="params">self, retain_graph=<span class="literal">True</span></span>):</span></span><br><span class="line">        self.loss.backward(retain_graph=retain_graph)</span><br><span class="line">        <span class="keyword">return</span> self.loss</span><br></pre></td></tr></table></figure><p>注意：</p><blockquote><p>尽管命名为内容损失，但它实际上不是真正的PyTorch损失函数。如果你想要定义内容损失函数作为PyTorch损失，你需要创建PyTorch自动求导函数并在反向传播中重新计算、实现梯度。</p></blockquote><h5 id="（6）风格损失"><a href="#（6）风格损失" class="headerlink" title="（6）风格损失"></a>（6）风格损失</h5><p>我们首先需要定义计算G<del>XL</del>的模型。F<del>XL</del>转为KxN的矩阵，设为<img src="https://gitee.com/zr001/my-picture-bed/raw/master/1593999621337.png">，其中K为特征图在L层的数量，N为特征图向量F^k^<del>XL</del>的长度。<img src="https://gitee.com/zr001/my-picture-bed/raw/master/1593999621337.png">的第k行为F^k^<del>XL</del>。有<img src="https://gitee.com/zr001/my-picture-bed/raw/master/1593999863283.png">。鉴于此，实现模型变得很简单：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GramMatrix</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, <span class="built_in">input</span></span>):</span></span><br><span class="line">        a, b, c, d = <span class="built_in">input</span>.size()  <span class="comment"># a=batch size(=1)</span></span><br><span class="line">        <span class="comment"># b=number of feature maps</span></span><br><span class="line">        <span class="comment"># (c,d)=dimensions of a f. map (N=c*d)</span></span><br><span class="line"></span><br><span class="line">        features = <span class="built_in">input</span>.view(a * b, c * d)  <span class="comment"># resise F_XL into \hat F_XL</span></span><br><span class="line"></span><br><span class="line">        G = torch.mm(features, features.t())  <span class="comment"># compute the gram product</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># we &#x27;normalize&#x27; the values of the gram matrix</span></span><br><span class="line">        <span class="comment"># by dividing by the number of element in each feature maps.</span></span><br><span class="line">        <span class="keyword">return</span> G.div(a * b * c * d)</span><br></pre></td></tr></table></figure><p>特征图的维度越长，gram 矩阵的值越大。 因此，如果我们不用N归一化，第一层计算的损失（池化层之前）将决定梯度下降。我们并不想如此，最深的层拥有最有趣的风格特征。我们定义风格损失的方式类似于内容损失，但我们需要增加 <code>gramMatrix</code>  作为参数：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StyleLoss</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, target, weight</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(StyleLoss, self).__init__()</span><br><span class="line">        self.target = target.detach() * weight</span><br><span class="line">        self.weight = weight</span><br><span class="line">        self.gram = GramMatrix()</span><br><span class="line">        self.criterion = nn.MSELoss()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, <span class="built_in">input</span></span>):</span></span><br><span class="line">        self.output = <span class="built_in">input</span>.clone()</span><br><span class="line">        self.G = self.gram(<span class="built_in">input</span>)</span><br><span class="line">        self.G.mul_(self.weight)</span><br><span class="line">        self.loss = self.criterion(self.G, self.target)</span><br><span class="line">        <span class="keyword">return</span> self.output</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backward</span>(<span class="params">self, retain_graph=<span class="literal">True</span></span>):</span></span><br><span class="line">        self.loss.backward(retain_graph=retain_graph)</span><br><span class="line">        <span class="keyword">return</span> self.loss</span><br></pre></td></tr></table></figure><h5 id="（7）载入神经网络"><a href="#（7）载入神经网络" class="headerlink" title="（7）载入神经网络"></a>（7）载入神经网络</h5><p>我们使用VGG19。只需要它特征提取部分的网络：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cnn = models.vgg19(pretrained=<span class="literal">True</span>).features</span><br><span class="line"></span><br><span class="line"><span class="comment"># move it to the GPU if possible:</span></span><br><span class="line"><span class="keyword">if</span> use_cuda:</span><br><span class="line">    cnn = cnn.cuda()</span><br></pre></td></tr></table></figure><p>我们想要在我们的网络相关层中添加风格和内容损失作为附加的透明层。为此，我们创建了一个新的序贯模型，在模型添加VGG19模型和我们的损失模型：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># desired depth layers to compute style/content losses :</span></span><br><span class="line">content_layers_default = [<span class="string">&#x27;conv_4&#x27;</span>]</span><br><span class="line">style_layers_default = [<span class="string">&#x27;conv_1&#x27;</span>, <span class="string">&#x27;conv_2&#x27;</span>, <span class="string">&#x27;conv_3&#x27;</span>, <span class="string">&#x27;conv_4&#x27;</span>, <span class="string">&#x27;conv_5&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_style_model_and_losses</span>(<span class="params">cnn, style_img, content_img,</span></span></span><br><span class="line"><span class="params"><span class="function">                               style_weight=<span class="number">1000</span>, content_weight=<span class="number">1</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                               content_layers=content_layers_default,</span></span></span><br><span class="line"><span class="params"><span class="function">                               style_layers=style_layers_default</span>):</span></span><br><span class="line">    cnn = copy.deepcopy(cnn)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># just in order to have an iterable access to or list of content/syle</span></span><br><span class="line">    <span class="comment"># losses</span></span><br><span class="line">    content_losses = []</span><br><span class="line">    style_losses = []</span><br><span class="line"></span><br><span class="line">    model = nn.Sequential()  <span class="comment"># the new Sequential module network</span></span><br><span class="line">    gram = GramMatrix()  <span class="comment"># we need a gram module in order to compute style targets</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># move these modules to the GPU if possible:</span></span><br><span class="line">    <span class="keyword">if</span> use_cuda:</span><br><span class="line">        model = model.cuda()</span><br><span class="line">        gram = gram.cuda()</span><br><span class="line"></span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> layer <span class="keyword">in</span> <span class="built_in">list</span>(cnn):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(layer, nn.Conv2d):</span><br><span class="line">            name = <span class="string">&quot;conv_&quot;</span> + <span class="built_in">str</span>(i)</span><br><span class="line">            model.add_module(name, layer)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> name <span class="keyword">in</span> content_layers:</span><br><span class="line">                <span class="comment"># add content loss:</span></span><br><span class="line">                target = model(content_img).clone()</span><br><span class="line">                content_loss = ContentLoss(target, content_weight)</span><br><span class="line">                model.add_module(<span class="string">&quot;content_loss_&quot;</span> + <span class="built_in">str</span>(i), content_loss)</span><br><span class="line">                content_losses.append(content_loss)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> name <span class="keyword">in</span> style_layers:</span><br><span class="line">                <span class="comment"># add style loss:</span></span><br><span class="line">                target_feature = model(style_img).clone()</span><br><span class="line">                target_feature_gram = gram(target_feature)</span><br><span class="line">                style_loss = StyleLoss(target_feature_gram, style_weight)</span><br><span class="line">                model.add_module(<span class="string">&quot;style_loss_&quot;</span> + <span class="built_in">str</span>(i), style_loss)</span><br><span class="line">                style_losses.append(style_loss)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(layer, nn.ReLU):</span><br><span class="line">            name = <span class="string">&quot;relu_&quot;</span> + <span class="built_in">str</span>(i)</span><br><span class="line">            model.add_module(name, layer)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> name <span class="keyword">in</span> content_layers:</span><br><span class="line">                <span class="comment"># add content loss:</span></span><br><span class="line">                target = model(content_img).clone()</span><br><span class="line">                content_loss = ContentLoss(target, content_weight)</span><br><span class="line">                model.add_module(<span class="string">&quot;content_loss_&quot;</span> + <span class="built_in">str</span>(i), content_loss)</span><br><span class="line">                content_losses.append(content_loss)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> name <span class="keyword">in</span> style_layers:</span><br><span class="line">                <span class="comment"># add style loss:</span></span><br><span class="line">                target_feature = model(style_img).clone()</span><br><span class="line">                target_feature_gram = gram(target_feature)</span><br><span class="line">                style_loss = StyleLoss(target_feature_gram, style_weight)</span><br><span class="line">                model.add_module(<span class="string">&quot;style_loss_&quot;</span> + <span class="built_in">str</span>(i), style_loss)</span><br><span class="line">                style_losses.append(style_loss)</span><br><span class="line"></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(layer, nn.MaxPool2d):</span><br><span class="line">            name = <span class="string">&quot;pool_&quot;</span> + <span class="built_in">str</span>(i)</span><br><span class="line">            model.add_module(name, layer)  <span class="comment"># ***</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> model, style_losses, content_losses</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意：</p><blockquote><p>论文作者建议把最大池化改为平均池化。AlexNext相对于VGG19是一个小网络，论文中使用它测试时效果没什么区别。但是你如果想按照论文所述去替换，可以用下面几行内容：<br><code>avgpool = nn.AvgPool2d(kernel_size=layer.kernel_size, stride=layer.stride, padding = layer.padding) model.add_module(name,avgpool)</code></p></blockquote><h5 id="（8）输入图像"><a href="#（8）输入图像" class="headerlink" title="（8）输入图像"></a>（8）输入图像</h5><p>为了简化，还是让图像的维度保持一致。图像可以是白噪声或者只是内容图像的copy：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">input_img = content_img.clone()</span><br><span class="line"><span class="comment"># if you want to use a white noise instead uncomment the below line:</span></span><br><span class="line"><span class="comment"># input_img = Variable(torch.randn(content_img.data.size())).type(dtype)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># add the original input image to the figure:</span></span><br><span class="line">plt.figure()</span><br><span class="line">imshow(input_img.data, title=<span class="string">&#x27;Input Image&#x27;</span>)</span><br></pre></td></tr></table></figure><p>结果：<br><img src="https://cdn.jsdelivr.net/gh/WINNERZR01/WINNERZR01-2022picturebed/writeimg/202201151709439.png" alt="输入图像"></p><h5 id="（9）梯度下降"><a href="#（9）梯度下降" class="headerlink" title="（9）梯度下降"></a>（9）梯度下降</h5><p>使用L-BFGS算法。不想训练一个网络，我们想训练我们的输入图像，未最小化内容风格损失。我们创建L-BFGS优化器，传入我们的图像作为需要优化的变量。但是optim.LBFGS的第一参数为含梯度的PyTorch变量variable列表。我们的输入是变量，但是没有梯度。我们利用输入图像构建一个Parameter对象来使其具有梯度，这样就可以输入优化器了：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_input_param_optimizer</span>(<span class="params">input_img</span>):</span></span><br><span class="line">    <span class="comment"># this line to show that input is a parameter that requires a gradient</span></span><br><span class="line">    input_param = nn.Parameter(input_img.data)</span><br><span class="line">    optimizer = optim.LBFGS([input_param])</span><br><span class="line">    <span class="keyword">return</span> input_param, optimizer</span><br></pre></td></tr></table></figure><p>最后一步：<br>循环，每次输入新的图像来计算新的损失我们利用反向传播自动计算损失的梯度并更新变量。优化器需要一个“closure”作为参数：一个重新评估模型并返回损失的函数。这有个问题，优化后的图像像素值在负无穷到正无穷之间，因此每次都需要调整图像像素值在0到1之间。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_style_transfer</span>(<span class="params">cnn, content_img, style_img, input_img, num_steps=<span class="number">100</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                       style_weight=<span class="number">1000</span>, content_weight=<span class="number">1</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Run the style transfer.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Building the style transfer model..&#x27;</span>)</span><br><span class="line">    model, style_losses, content_losses = get_style_model_and_losses(cnn,</span><br><span class="line">        style_img, content_img, style_weight, content_weight)</span><br><span class="line">    input_param, optimizer = get_input_param_optimizer(input_img)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Optimizing..&#x27;</span>)</span><br><span class="line">    run = [<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">while</span> run[<span class="number">0</span>] &lt;= num_steps:</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">closure</span>():</span></span><br><span class="line">            <span class="comment"># correct the values of updated input image</span></span><br><span class="line">            input_param.data.clamp_(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line">            model(input_param)</span><br><span class="line">            style_score = <span class="number">0</span></span><br><span class="line">            content_score = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> sl <span class="keyword">in</span> style_losses:</span><br><span class="line">                style_score += sl.backward()</span><br><span class="line">            <span class="keyword">for</span> cl <span class="keyword">in</span> content_losses:</span><br><span class="line">                content_score += cl.backward()</span><br><span class="line"></span><br><span class="line">            run[<span class="number">0</span>] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> run[<span class="number">0</span>] % <span class="number">50</span> == <span class="number">0</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;run &#123;&#125;:&quot;</span>.<span class="built_in">format</span>(run))</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;Style Loss : &#123;:4f&#125; Content Loss: &#123;:4f&#125;&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">                    style_score.item[<span class="number">0</span>], content_score.item[<span class="number">0</span>]))</span><br><span class="line">                <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> style_score + content_score</span><br><span class="line"></span><br><span class="line">        optimizer.step(closure)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># a last correction...</span></span><br><span class="line">    input_param.data.clamp_(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> input_param.data</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后，运行这个算法：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">output = run_style_transfer(cnn, content_img, style_img, input_img)</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line">imshow(output, title=<span class="string">&#x27;Output Image&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sphinx_gallery_thumbnail_number = 4</span></span><br><span class="line">plt.ioff()</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果：</p><blockquote><p><img src="https://cdn.jsdelivr.net/gh/WINNERZR01/WINNERZR01-2022picturebed/writeimg/202201151709990.png" alt="最终结果"></p></blockquote><h5 id="（10）结果展示"><a href="#（10）结果展示" class="headerlink" title="（10）结果展示"></a>（10）结果展示</h5><p><img src="https://cdn.jsdelivr.net/gh/WINNERZR01/WINNERZR01-2022picturebed/writeimg/202201151709903.jpeg" alt="原图" style="zoom:20%;" /><img src="https://cdn.jsdelivr.net/gh/WINNERZR01/WINNERZR01-2022picturebed/writeimg/202201151709012.jpeg" alt="梵高星月夜" style="zoom:120%;" /><img src="https://cdn.jsdelivr.net/gh/WINNERZR01/WINNERZR01-2022picturebed/writeimg/202201151710577.jpeg" alt="齐白石虾" style="zoom:120%;" /></p><pre><code>         `原图`                        `星月夜-梵高`                     `虾-齐白石`</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gitbook</title>
      <link href="/Gitbook/Gitbook/"/>
      <url>/Gitbook/Gitbook/</url>
      
        <content type="html"><![CDATA[<h1 id="Gitbook部署"><a href="#Gitbook部署" class="headerlink" title="Gitbook部署"></a>Gitbook部署</h1><h2 id="github创建新仓库"><a href="#github创建新仓库" class="headerlink" title="github创建新仓库"></a>github创建新仓库</h2><ul><li>不用选择自动添加<code>README.md</code></li><li>等会在本地上传至远程仓库</li><li>添加之后弹出的界面：<ul><li><img src="https://cdn.jsdelivr.net/gh/WINNERZR01/WINNERZR01-2022picturebed/writeimg/202201141123078.png" style="zoom:110%;" /></li></ul></li></ul><h3 id="本地gitbook"><a href="#本地gitbook" class="headerlink" title="本地gitbook"></a>本地gitbook</h3><h4 id="gitbook基本命令"><a href="#gitbook基本命令" class="headerlink" title="gitbook基本命令"></a>gitbook基本命令</h4><ul><li><p>①<code>gitbook help</code>列出gitbook所有的命令</p></li><li><p>②<code>gitbook --help</code>输出<code>gitbook-cli</code>的帮助信息</p></li><li><p>③<code>gitbook build</code>生成静态网页</p></li><li><p>④<code>gitbook serve</code>生成静态网页并运行本地服务器</p></li><li><p>⑤<code>gitbook ls</code>列出本地所有的<code>gitbook</code>版本</p></li><li><p>⑥<code>gitbook update</code>更新到<code>gitbook</code>的最新版本</p><h4 id="gitbook源文件备份"><a href="#gitbook源文件备份" class="headerlink" title="gitbook源文件备份"></a>gitbook源文件备份</h4></li><li><p>①<code>git init</code>初始化本地的<code>gitbook</code>文件夹，会生成一个<code>.git</code>文件夹</p></li><li><p>②<code>git remote add origin 仓库git地址</code></p></li><li><p>③<code>git add .</code>添加本地<code>gitbook</code>文件夹的所有源文件</p></li><li><p>④<code>git commit -m &quot;备注信息&quot;</code></p></li><li><p>⑤<code>git push -u origin main</code> <code>-u</code>表示首先创建<code>main</code>分支，将本地<code>git</code>提交推送至远程<code>git</code>仓库的<code>main</code>分支</p></li></ul><h4 id="gitbook部署到gh-pages"><a href="#gitbook部署到gh-pages" class="headerlink" title="gitbook部署到gh-pages"></a>gitbook部署到gh-pages</h4><ul><li>① 首先在本地备份一份生成的<code>_book</code>文件夹</li><li>②<code>git checkout -b（创建并进行分支的切换）gh-pages</code></li><li>③删除所有文件，除<code>.git</code>文件夹</li><li>④将第一步复制的<code>_book</code>文件夹的内容粘贴到切换分支后的目录中去</li><li>⑤<code>git add .</code>添加本地<code>gitbook</code>文件夹的<code>_book</code>生成的内容</li><li>⑥<code>git commit -m &quot;备注信息&quot;</code></li><li>⑦<code>git push origin gh-pages</code>将本地<code>git</code>提交推送至远程<code>git</code>仓库的 <code>gh-pages</code> 分支</li></ul><h1 id="Gitbook脚本（原创）"><a href="#Gitbook脚本（原创）" class="headerlink" title="Gitbook脚本（原创）"></a>Gitbook脚本（原创）</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Start working&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;First step:Enter your notebook name: &quot;</span></span><br><span class="line"><span class="built_in">read</span> name</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;The current notebook is <span class="variable">$name</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Second step:Change working directory&quot;</span></span><br><span class="line"><span class="built_in">cd</span> ./<span class="variable">$name</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;Now the working directory is  &quot;</span> </span><br><span class="line"><span class="built_in">pwd</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Third step:Build the notebook&quot;</span></span><br><span class="line">gitbook build</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Forth step:Start add files&quot;</span></span><br><span class="line">git add .</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;Fifth step:Enter the commit message:&quot;</span></span><br><span class="line"><span class="built_in">read</span> message</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;The changes are <span class="variable">$message</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Sixth step:Commit changes&quot;</span></span><br><span class="line">git commit -m <span class="string">&quot;<span class="variable">$message</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Seventh step:Git push changes&quot;</span></span><br><span class="line">git push origin main</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Eighth step:Copy _book&#x27;s files to Temporary storage &quot;</span></span><br><span class="line">cp -rf ./_book/* ../TemporaryStorage</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Ninth step:Checkout gh-pages&quot;</span></span><br><span class="line">git checkout gh-pages</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Tenth step:Delete all files&quot;</span></span><br><span class="line">rm -rf * </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Eleventh step:Copy Temporary storage files&quot;</span></span><br><span class="line">cp -rf ../TemporaryStorage/* ./</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Twelfth step:Delete Temporary storage files&quot;</span></span><br><span class="line">rm -rf ../TemporaryStorage/*</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Thirteenth step:Repeat the submission step&quot;</span></span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;<span class="variable">$message</span>&quot;</span></span><br><span class="line">git push origin gh-pages</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Fourteen step:Switch to main branch&quot;</span></span><br><span class="line">git checkout main</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;End step:Everything is done,have a nice day!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># rm -rf `ls | grep -v &quot;.git 删除当前文件夹下不含.git字样的文件&quot;</span></span><br><span class="line"><span class="comment"># rm -rf * 删除当前文件夹下所有文件但是不会删除隐藏文件夹</span></span><br><span class="line"><span class="comment"># cp -rf * ../demo 将当前文件夹下的所有文件复制到demo文件夹下`</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Gitbook </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gitbook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KeyShot</title>
      <link href="/KeyShot/KeyShot/"/>
      <url>/KeyShot/KeyShot/</url>
      
        <content type="html"><![CDATA[<h1 id="KeyShotXR"><a href="#KeyShotXR" class="headerlink" title="KeyShotXR"></a>KeyShotXR</h1><h2 id="OpenMV"><a href="#OpenMV" class="headerlink" title="OpenMV"></a>OpenMV</h2><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">    <iframe src="https://winnerzr.github.io/keyshotXR/" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"> </iframe></div><h2 id="AK-47"><a href="#AK-47" class="headerlink" title="AK-47"></a>AK-47</h2><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">    <iframe src="https://winnerzr.github.io/ak-47/" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"> </iframe></div>-----]]></content>
      
      
      <categories>
          
          <category> KeyShot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> KeyShot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GeomagicDesignX安装教程</title>
      <link href="/Geomagic-DesignX/GeomagicDesignX%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
      <url>/Geomagic-DesignX/GeomagicDesignX%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="GeomagicDesignX安装"><a href="#GeomagicDesignX安装" class="headerlink" title="GeomagicDesignX安装"></a>GeomagicDesignX安装</h1><blockquote><p><code>安装包</code>：有两个版本的软件，大家根据自己需要安装即可</p><p><a href="https://pan.baidu.com/s/1Xhwm_V-6W9iE8m7xyCcSUg">GeomagicDesignX2016</a>提取码：<code>h4gb</code></p><p><a href="https://pan.baidu.com/s/1PNGM5bo4aWhnXsqB2dKY4A">GeomagicDesignX2019</a>提取码：<code>jydr</code></p></blockquote><h2 id="GeomagicDesignX2016安装教程"><a href="#GeomagicDesignX2016安装教程" class="headerlink" title="GeomagicDesignX2016安装教程"></a>GeomagicDesignX2016安装教程</h2><ul><li>1.下载好2016版安装包解压。<ul><li><img src="https://cdn.jsdelivr.net/gh/WINNERZR01/WINNERZR01-2022picturebed/writeimg/202201131632805.png" alt="1"></li></ul></li><li>2.打开下载好的文件夹。<ul><li><img src="https://cdn.jsdelivr.net/gh/WINNERZR01/WINNERZR01-2022picturebed/writeimg/202201131632884.png" alt="2"></li></ul></li><li>3.双击打开<code>主程序</code>文件夹。<ul><li><img src="https://cdn.jsdelivr.net/gh/WINNERZR01/WINNERZR01-2022picturebed/writeimg/202201131632085.png" alt="3"></li></ul></li><li>4.右键以管理员身份运行<code>setup</code>程序，进行安装。<ul><li><img src="https://cdn.jsdelivr.net/gh/WINNERZR01/WINNERZR01-2022picturebed/writeimg/202201131632199.png" alt="4"></li></ul></li><li>5.安装步骤<ul><li><img src="https://cdn.jsdelivr.net/gh/WINNERZR01/WINNERZR01-2022picturebed/writeimg/202201131633421.png" alt="5"></li><li><img src="https://cdn.jsdelivr.net/gh/WINNERZR01/WINNERZR01-2022picturebed/writeimg/202201131633824.png" alt="6"></li><li><img src="https://cdn.jsdelivr.net/gh/WINNERZR01/WINNERZR01-2022picturebed/writeimg/202201131633106.png" alt="7"></li><li><img src="https://cdn.jsdelivr.net/gh/WINNERZR01/WINNERZR01-2022picturebed/writeimg/202201131633464.png" alt="8"></li><li><img src="https://cdn.jsdelivr.net/gh/WINNERZR01/WINNERZR01-2022picturebed/writeimg/202201131633769.png" alt="9"></li><li><img src="https://cdn.jsdelivr.net/gh/WINNERZR01/WINNERZR01-2022picturebed/writeimg/202201131633943.png" alt="10"></li><li><img src="https://cdn.jsdelivr.net/gh/WINNERZR01/WINNERZR01-2022picturebed/writeimg/202201131633342.png" alt="11"></li><li>首先更改安装位置，避免安装在<code>C</code>盘(只有<code>C</code>盘除外)，<ul><li>在其他盘新建文件夹，名称随意（建议名字：<code>DX</code>）<img src="https://cdn.jsdelivr.net/gh/WINNERZR01/WINNERZR01-2022picturebed/writeimg/202201131633279.png" alt="12"></li><li><img src="https://cdn.jsdelivr.net/gh/WINNERZR01/WINNERZR01-2022picturebed/writeimg/202201131633661.png" alt="13"></li><li>找到你新建的<code>DX</code>文件夹，并选中之后点击确定<img src="https://cdn.jsdelivr.net/gh/WINNERZR01/WINNERZR01-2022picturebed/writeimg/202201131633530.png" alt="14"></li></ul></li><li><img src="https://cdn.jsdelivr.net/gh/WINNERZR01/WINNERZR01-2022picturebed/writeimg/202201131634592.png" alt="15"></li><li><img src="https://cdn.jsdelivr.net/gh/WINNERZR01/WINNERZR01-2022picturebed/writeimg/202201131634257.png" alt="16">             </li><li>等待安装完成之后不能立即打开，此时还未破解，<img src="https://cdn.jsdelivr.net/gh/WINNERZR01/WINNERZR01-2022picturebed/writeimg/202201131634822.png" alt="17"></li></ul></li><li>6.破解步骤<ul><li>右键桌面的<code>DX</code>图标，打开文件所在位置<img src="https://cdn.jsdelivr.net/gh/WINNERZR01/WINNERZR01-2022picturebed/writeimg/202201131634421.png" alt="18"></li><li>打开<code>bin</code>文件夹<img src="https://cdn.jsdelivr.net/gh/WINNERZR01/WINNERZR01-2022picturebed/writeimg/202201131634805.png" alt="19"></li><li>找到<code>GSFlexLicense.dll</code>文件，右键重命名为<code>GSFlexLicense.dl1</code>，其实就是把最后一个<code>l</code>改成1<img src="https://cdn.jsdelivr.net/gh/WINNERZR01/WINNERZR01-2022picturebed/writeimg/202201131634467.png" alt="20"></li><li>打开<code>Crack</code>文件夹<img src="https://cdn.jsdelivr.net/gh/WINNERZR01/WINNERZR01-2022picturebed/writeimg/202201131634856.png" alt="21"></li><li>将下载好的破解文件夹<code>crack</code>里的<code>GSFlexLicense.dll</code>拖动到前面安装好的<code>bin</code>文件夹当中。<img src="https://cdn.jsdelivr.net/gh/WINNERZR01/WINNERZR01-2022picturebed/writeimg/202201131634317.png" alt="22"></li><li>破解完成</li></ul></li><li>7.设置与导入<ul><li>设置<img src="https://cdn.jsdelivr.net/gh/WINNERZR01/WINNERZR01-2022picturebed/writeimg/202201131634722.png" alt="23"></li><li>导入<img src="https://cdn.jsdelivr.net/gh/WINNERZR01/WINNERZR01-2022picturebed/writeimg/202201131634230.png" alt="24"></li></ul></li></ul><h2 id="GeomagicDesignX2019安装教程"><a href="#GeomagicDesignX2019安装教程" class="headerlink" title="GeomagicDesignX2019安装教程"></a>GeomagicDesignX2019安装教程</h2><ul><li>安装过程同上</li><li>破解过程略有不同<ul><li>安装完成之后<ul><li><img src="https://cdn.jsdelivr.net/gh/WINNERZR01/WINNERZR01-2022picturebed/writeimg/202201131635898.png" alt="25"></li><li>拖动下载好的安装包<code>Crack</code>文件夹中的<code>bin</code>文件夹到上一步打开的位置中，并且选择全部替换。</li></ul></li></ul></li><li>破解之后打开运行即可，设置类似</li></ul><blockquote><p>作者：<a href="https://winnerzr.xyz/">WINNERZR</a>，转载请标明，并邮件告知 <a href="mailto:&#119;&#x69;&#x6e;&#x6e;&#x65;&#114;&#122;&#x72;&#x40;&#49;&#54;&#x33;&#46;&#99;&#111;&#109;">&#119;&#x69;&#x6e;&#x6e;&#x65;&#114;&#122;&#x72;&#x40;&#49;&#54;&#x33;&#46;&#99;&#111;&#109;</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Geomagic DesignX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> Geomagic DesignX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Anaconda相关命令</title>
      <link href="/Python/Anaconda%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"/>
      <url>/Python/Anaconda%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="查看anaconda版本信息"><a href="#查看anaconda版本信息" class="headerlink" title="查看anaconda版本信息"></a>查看anaconda版本信息</h1><ul><li><code>conda --version</code> ：查看版本信息。</li></ul><h1 id="升级相关"><a href="#升级相关" class="headerlink" title="升级相关"></a>升级相关</h1><ul><li><code>conda upgrade --all</code>：升级所有工具包。</li><li><code>conda update conda</code>：检查更新当前<code>conda</code>。</li></ul><h1 id="管理虚拟环境"><a href="#管理虚拟环境" class="headerlink" title="管理虚拟环境"></a>管理虚拟环境</h1><ul><li><p>使用<code>anaconda</code>可以为我们创建所需要的特定的虚拟环境。</p></li><li><p><code>conda create --name env_name python=xxx</code>：创建你所需要的<code>python虚拟环境</code>。</p></li><li><p><code>激活环境</code></p><ul><li>Windows：<code>activate env_name</code>：切换到所创建的<code>python虚拟环境</code>。</li><li>Mac/Linux：<code>source activate env_name  </code>。</li></ul></li><li><p><code>conda env list</code>或<code>conda info -e</code>：查看所有的环境。</p></li><li><p><code>conda remove --name env_name --all</code>：删除一个已有的<code>python虚拟环境</code>。</p></li><li><p><code>conda remove --name $your_env_name $package_name</code>：不进入任何的虚拟环境，指定要删除的哪个环境的哪个包。</p></li><li><p><code>deactivate env_name  </code>：退出环境。</p></li><li><p><code>conda env export &gt; environment.yml</code>：分享环境，会在当前工作目录下生成一个。environment.yml文件，拿到environment.yml文件后，将该文件放在工作目录下，可以通过命令<code>conda env create -f environment.yml</code>从该文件创建环境。</p></li></ul><h1 id="conda常用命令"><a href="#conda常用命令" class="headerlink" title="conda常用命令"></a>conda常用命令</h1><ul><li><code>conda list</code>：查看安装了哪些包。</li><li><code>conda install package_name(包名)</code>：安装指定包。</li></ul><h1 id="使用Qtconsole"><a href="#使用Qtconsole" class="headerlink" title="使用Qtconsole"></a>使用<code>Qtconsole</code></h1><ul><li>直接运行<code>jupyter qtconsole</code>（需要首先<code>pip install jupyter</code>）。</li></ul><h1 id="使用jupyter-notebook"><a href="#使用jupyter-notebook" class="headerlink" title="使用jupyter notebook"></a>使用<code>jupyter notebook</code></h1><ul><li>在任意文件夹中打开<code>cmd</code>：输入<code>jupyter notebook</code>，好处是生成的<code>ipynb</code>文件会保存在当前的文件夹中。</li><li>启动之后会打开一个网页</li></ul><h1 id="使用jupyterlab"><a href="#使用jupyterlab" class="headerlink" title="使用jupyterlab "></a>使用<code>jupyterlab </code></h1><ul><li><code>Jupyter Lab</code> 的启用 和 <code>Jupyter Notebook</code> 方法一样，只需要将输入的 <code>jupyter notebook</code> 换成 <code>jupyter lab</code> 即可。</li><li>我们点击 <code>jupyterlab</code> 下面的 <code>Launch</code> ，会在默认浏览器（我这里是 Chrome）打开 <em><a href="http://localhost:8888/lab">http://localhost:8888/lab</a></em> 这样一个东东，这里就可以输入 Python 代码啦，来一句 Hello World 吧。</li></ul><blockquote><p>友情链接：<a href="https://blog.csdn.net/ITLearnHall/article/details/81708148">CSDN</a></p></blockquote><h1 id="彻底卸载anaconda"><a href="#彻底卸载anaconda" class="headerlink" title="彻底卸载anaconda"></a>彻底卸载anaconda</h1><ul><li>打开<code>anaconda prompt</code>：<ul><li>输入<code>conda install anaconda-clean</code></li></ul></li><li>输入<code>anaconda-clean --yes</code></li><li>通过<code>Uninstall-Anaconda3.exe</code></li></ul><h1 id="急救方法"><a href="#急救方法" class="headerlink" title="急救方法"></a>急救方法</h1><ul><li><code>终端</code>用命令<code>anaconda-navigator</code>运行<code>anaconda</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> Python </tag>
            
            <tag> Anaconda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021-vscode-stats</title>
      <link href="/Vscode/2021-vscode-stats/"/>
      <url>/Vscode/2021-vscode-stats/</url>
      
        <content type="html"><![CDATA[<img src="https://wakatime.com/static/img/wakatime.svg" alt="wakatime" style="zoom:50%;" /><p><img src="https://cdn.jsdelivr.net/gh/WINNERZR01/WINNERZR01-2022picturebed/writeimg/202201131601563.png" alt="personalized-2021-stats"></p><blockquote><p><em>2022</em> 继续学习。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Vscode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> Vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>chrome生成网页长图</title>
      <link href="/Chrome/chrome%E7%94%9F%E6%88%90%E7%BD%91%E9%A1%B5%E9%95%BF%E5%9B%BE/"/>
      <url>/Chrome/chrome%E7%94%9F%E6%88%90%E7%BD%91%E9%A1%B5%E9%95%BF%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="在需要截取网页长图的页面按下"><a href="#在需要截取网页长图的页面按下" class="headerlink" title="在需要截取网页长图的页面按下"></a>在需要截取网页长图的页面按下</h1><h2 id="Windows-F12"><a href="#Windows-F12" class="headerlink" title="Windows: F12"></a>Windows: F12</h2><h2 id="Mac-command-option-I"><a href="#Mac-command-option-I" class="headerlink" title="Mac: command + option + I"></a>Mac: <code>command + option + I</code></h2><h1 id="再按下"><a href="#再按下" class="headerlink" title="再按下"></a>再按下</h1><h2 id="Windows-Ctrl-Shift-P"><a href="#Windows-Ctrl-Shift-P" class="headerlink" title="Windows: Ctrl + Shift + P"></a>Windows: <code>Ctrl + Shift + P</code></h2><h2 id="Mac-command-shift-P"><a href="#Mac-command-shift-P" class="headerlink" title="Mac: command + shift + P"></a>Mac: <code>command + shift + P</code></h2><h1 id="再输入"><a href="#再输入" class="headerlink" title="再输入"></a>再输入</h1><h2 id="Capture-full-size-screenshot"><a href="#Capture-full-size-screenshot" class="headerlink" title="Capture full size screenshot"></a><code>Capture full size screenshot</code></h2><hr><blockquote><p>敲下回车保存至下载目录。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Chrome </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> Chrome </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
